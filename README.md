# Resources

* http://www.downloads.seng.de/HowTo_ToolChain_STM32_Ubuntu.pdf
* http://embedded.kleier.selfhost.me/lockup.php
* http://fun-tech.se/stm32/linker/index.php
* Developing a Generic Hard Fault handler for ARM Cortex-M3/Cortex-M4: https://community.arm.com/servlet/JiveServlet/previewBody/7835-102-2-12371/Developing%20a%20Generic%20Hard%20Fault%20handler%20for%20ARM.pdf

        
* http://www.st.com/web/en/catalog/tools/PF257890
** STSW-STM32054	
        
# Programming with OpenOCD
        
        reset halt
        flash probe 0 
        stm32f1x mass_erase 0
        flash write_bank 0 test1.elf.bin 0
        reset run 

# Registers

## CPU Registers

The Stack Pointer (SP) is register R13. In Thread mode, bit[1] of the CONTROL register indicates the stack pointer to use:
0 = Main Stack Pointer (MSP). This is the reset value.
1 = Process Stack Pointer (PSP).

## Configurable Fault Status Register: 0xE000ED28


## Hard Fault Status Register: 0xE000ED2C

Table 4.28. HFSR bit assignments
Bits	Name	Function
[31]	DEBUGEVT	Reserved for Debug use. When writing to the register you must write 0 to this bit, otherwise behavior is Unpredictable.
[30]	FORCED	
Indicates a forced hard fault, generated by escalation of a fault with configurable priority that cannot be handles, either because of priority or because it is disabled:
0 = no forced HardFault
1 = forced HardFault.
When this bit is set to 1, the HardFault handler must read the other fault status registers to find the cause of the fault.
[29:2]	-	Reserved.
[1]	VECTTBL	
Indicates a BusFault on a vector table read during exception processing:
0 = no BusFault on vector table read
1 = BusFault on vector table read.
This error is always handled by the hard fault handler.
When this bit is set to 1, the PC value stacked for the exception return points to the instruction that was preempted by the exception.
[0]	-	Reserved.

## Debug Fault Status Register: 0xE000ED30


## Auxiliary Fault Status Register: 0xE000ED3C
